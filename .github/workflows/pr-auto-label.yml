name: Auto label PR by title and changed files

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, ready_for_review]

jobs:
  auto-label-pr:
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply PR labels
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("node:fs");
            const config = JSON.parse(
              fs.readFileSync(".github/labeler/config.json", "utf8"),
            );

            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = pr.number;
            const isIntegrationPermissionError = (error) =>
              error?.status === 403 &&
              /resource not accessible by integration/i.test(
                error?.response?.data?.message || error?.message || "",
              );
            const title = (pr.title || "").toLowerCase();
            const body = (pr.body || "").toLowerCase();
            const text = `${title}\n${body}`;

            const current = (pr.labels || []).map((l) =>
              typeof l === "string" ? l : l.name,
            );

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: issueNumber,
              per_page: 100,
            });
            const changedPaths = files.map((file) =>
              (file.filename || "").toLowerCase(),
            );
            const totalChanges =
              Number(pr.additions || 0) + Number(pr.deletions || 0);

            const toRegex = (pattern) => new RegExp(pattern, "iu");
            const pathMatchesRule = (rule, path) => {
              const prefixes = rule.prefixes || [];
              const patterns = rule.patterns || [];
              return (
                prefixes.some((prefix) => path.startsWith(prefix.toLowerCase())) ||
                patterns.some((pattern) => toRegex(pattern).test(path))
              );
            };
            const matchesAnyPattern = (patterns, value) =>
              (patterns || []).some((pattern) => toRegex(pattern).test(value));
            const countMatches = (patterns, value) =>
              (patterns || []).reduce(
                (count, pattern) => count + (toRegex(pattern).test(value) ? 1 : 0),
                0,
              );

            const prCfg = config.pr || {};
            const typeRules = prCfg.type_rules || [];
            const areaPathRules = prCfg.area_path_rules || [];
            const sizeRules = prCfg.size_by_changed_lines || [];
            const managedTypeLabels = [
              "bug",
              "enhancement",
              "question",
              "documentation",
              "dependencies",
              "type:refactor",
              "type:chore",
              "type:performance",
            ];

            const areaLabels = new Set();
            for (const rule of areaPathRules) {
              if (changedPaths.some((path) => pathMatchesRule(rule, path))) {
                areaLabels.add(rule.label);
              }
            }
            if (matchesAnyPattern(prCfg.security_text_patterns, text)) {
              areaLabels.add("area:security");
            }
            if (areaLabels.size === 0) {
              areaLabels.add(prCfg.default_area || "area:plugin");
            }

            const typeLabel =
              current.find((name) => managedTypeLabels.includes(name)) ||
              typeRules
                .map((rule) => ({
                  label: rule.label,
                  score:
                    countMatches(rule.patterns, title) * 3 +
                    countMatches(rule.patterns, body),
                }))
                .filter((item) => item.score > 0)
                .sort((a, b) => b.score - a.score)[0]?.label ||
              null;

            const hasDocChanges = changedPaths.some((path) =>
              matchesAnyPattern(prCfg.doc_path_patterns, path),
            );
            const skipNeedDocFromText = matchesAnyPattern(
              prCfg.doc_skip_text_patterns,
              text,
            );
            const needDocMinChanges = Number(prCfg.need_doc_min_changes || 80);
            const hasCodeChangeNeedingDoc = changedPaths.some(
              (path) =>
                matchesAnyPattern(prCfg.need_doc_code_path_patterns, path) &&
                !matchesAnyPattern(prCfg.doc_exempt_path_patterns, path),
            );
            const onlyExemptChanges =
              changedPaths.length > 0 &&
              changedPaths.every((path) =>
                matchesAnyPattern(prCfg.doc_exempt_path_patterns, path),
              );
            const needDocLabel =
              !hasDocChanges &&
              !skipNeedDocFromText &&
              hasCodeChangeNeedingDoc &&
              !onlyExemptChanges &&
              totalChanges >= needDocMinChanges
                ? "need-update-doc"
                : null;

            let sizeLabel = "size:m";
            for (const rule of sizeRules) {
              if (totalChanges <= Number(rule.max)) {
                sizeLabel = rule.label;
                break;
              }
            }

            const toRemove = current.filter(
              (name) =>
                name.startsWith("area:") ||
                name.startsWith("size:") ||
                managedTypeLabels.includes(name) ||
                name === "need-update-doc",
            );
            for (const labelName of toRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  name: labelName,
                });
              } catch (error) {
                if (error.status !== 404) {
                  if (isIntegrationPermissionError(error)) {
                    core.warning(
                      "Skip PR auto-labeling: token cannot write labels in this context.",
                    );
                    return;
                  }
                  throw error;
                }
              }
            }

            const toAdd = [typeLabel, ...areaLabels, sizeLabel, needDocLabel].filter(
              Boolean,
            );
            if (toAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: toAdd,
                });
              } catch (error) {
                if (isIntegrationPermissionError(error)) {
                  core.warning(
                    "Skip PR auto-labeling: token cannot write labels in this context.",
                  );
                  return;
                }
                throw error;
              }
            }
