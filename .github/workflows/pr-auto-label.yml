name: Auto label PR by title and changed files

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, ready_for_review]

jobs:
  auto-label-pr:
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply PR labels
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("node:fs");
            const config = JSON.parse(
              fs.readFileSync(".github/labeler/config.json", "utf8"),
            );

            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = pr.number;
            const isIntegrationPermissionError = (error) =>
              error?.status === 403 &&
              /resource not accessible by integration/i.test(
                error?.response?.data?.message || error?.message || "",
              );
            const title = (pr.title || "").toLowerCase();
            const body = (pr.body || "").toLowerCase();
            const text = `${title}\n${body}`;

            const current = (pr.labels || []).map((l) =>
              typeof l === "string" ? l : l.name,
            );

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: issueNumber,
              per_page: 100,
            });
            const changedPaths = files.map((file) =>
              (file.filename || "").toLowerCase(),
            );
            const totalChanges =
              Number(pr.additions || 0) + Number(pr.deletions || 0);

            const toRegex = (pattern) => new RegExp(pattern, "iu");
            const pathMatchesRule = (rule, path) => {
              const prefixes = rule.prefixes || [];
              const patterns = rule.patterns || [];
              return (
                prefixes.some((prefix) => path.startsWith(prefix.toLowerCase())) ||
                patterns.some((pattern) => toRegex(pattern).test(path))
              );
            };
            const matchesAnyPattern = (patterns, value) =>
              (patterns || []).some((pattern) => toRegex(pattern).test(value));

            const prCfg = config.pr || {};
            const areaPathRules = prCfg.area_path_rules || [];
            const sizeRules = prCfg.size_by_changed_lines || [];

            const areaLabels = new Set();
            for (const rule of areaPathRules) {
              if (changedPaths.some((path) => pathMatchesRule(rule, path))) {
                areaLabels.add(rule.label);
              }
            }
            if (areaLabels.size === 0) {
              areaLabels.add(prCfg.default_area || "area:plugin");
            }

            const needDocFromPath = changedPaths.some((path) =>
              matchesAnyPattern(prCfg.doc_path_patterns, path),
            );
            const needDocFromText = matchesAnyPattern(prCfg.doc_text_patterns, text);
            const needDocLabel =
              needDocFromPath || needDocFromText ? "need-update-doc" : null;

            let sizeLabel = "size:m";
            for (const rule of sizeRules) {
              if (totalChanges <= Number(rule.max)) {
                sizeLabel = rule.label;
                break;
              }
            }

            const toRemove = current.filter(
              (name) =>
                name.startsWith("area:") ||
                name.startsWith("size:") ||
                name === "need-update-doc",
            );
            for (const labelName of toRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  name: labelName,
                });
              } catch (error) {
                if (error.status !== 404) {
                  if (isIntegrationPermissionError(error)) {
                    core.warning(
                      "Skip PR auto-labeling: token cannot write labels in this context.",
                    );
                    return;
                  }
                  throw error;
                }
              }
            }

            const toAdd = [...areaLabels, sizeLabel, needDocLabel].filter(Boolean);
            if (toAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: toAdd,
                });
              } catch (error) {
                if (isIntegrationPermissionError(error)) {
                  core.warning(
                    "Skip PR auto-labeling: token cannot write labels in this context.",
                  );
                  return;
                }
                throw error;
              }
            }
